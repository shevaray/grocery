
// index_1 - with objects for commands
// index_2: trying a new structure
// index_3: got half-way with moving the cursor off the main position. rewriting to complete
// index_4: complete rewriting, adding back in tab
// index_5: tab still elusive, but cursor, home del & many more keys
// index_6 try as a factory function with local hidden variables. good but meh, poluted namespace
// index_7 going back to index_5. Got questions working, now trying promisey stuff
// index_8 allow callbacks to send promises, that pause the text input but put things in buffer

/*
    New way of defining commands: functions

    'list` : 'ahead' args => { return list or }
             'run' args => { run command }

*/

/*
[{
    name: "delete",
    alias: "del",
    args: [{
        name: "all",
        alias: "a",
        args: 0,
        flags: [{
            name: "force",
            alias: "f",
            args: 0,
        },{
            name: "match",
            alias: "m",
            args: 1,
        }],
    }]
}]
*/

var colors = require('colors/safe');
var _ = require('underscore');

var json = a => JSON.stringify(a,null,2);

var leftChar = "\u001b[D";
var rightChar = "\u001b[C";

var keypress = require('keypress');
// make `process.stdin` begin emitting "keypress" events
keypress(process.stdin);

function escapeRegExp(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}

function rewriteText(str) {
    // console.log(`rewrite : ${json(str)}`);
    return str + str.split('').slice(1).map(a => leftChar).join('');
}

function rewriteLine(text,next) {
    if(text.length > next.length) {
        return '\r' + text.replace(/./g,' ') + text.replace(/./g,'\b') + next;
    } else {
        return '\r' + next;
    }

}

// Promise queuing

function promiseQueue(list,data,num) {
    if(!num) num = 0;
    if(list.length >= num) {
        return Promise.resolve(data);
    } else {
        try {
            var res = list[0](data);
            if(res && _.isFunction(res.then)) {
                return res.then(d => promiseQueue(list,d,num+1));
            } else {
                if(res) return promiseQueue(list,res,num+1);
                else return promiseQueue(list,data,num+1);
            }
        } catch(e) {
            return Promise.reject(e);
        }
        // promiseQueue(return new Promise(resolve => promiseQueue(list,))
    }
}

// var splitReg = /((?=["'])(?:"[^"\\]*(?:\\[\s\S][^"\\]*)*"|'[^'\\]*(?:\\[\s\S][^'\\]*)*'))/;

var colorList = ["black","red","green","yellow","blue","magenta","cyan","white","gray","grey"];
var bgList = ["bgBlack","bgRed","bgGreen","bgYellow","bgBlue","bgMagenta","bgCyan","bgWhite"];
var delims = ['"',"'"];
var regLoop = delims.map(a => `${a}[^${a}\\\\]*(?:\\\\[\s\S][^${a}\\\\]*)*${a}`).join("|");
var regStr = `((?=[${delims.join('')}])(?:${regLoop}))`;

var splitReg = new RegExp(regStr)


function splitArgs(text) {

    var a = text.split(splitReg);
    var b = [];
    for(var i=0;i<a.length;i++) {
        if(i%2) {
            b.push(a[i].replace(/^['"](.*)['"]$/,'$1'));
        } else {
            b = b.concat(a[i].trim().split(/ +/));
        }
    }

    return b.filter(a => a != "");

}

function parse(a) {
    var b = {};
    if(_.isArray(a)) {
        // console.log(`parse array ${a}`);
        for(var i in a) {
            b[a[i]] = true;
        }
    } else if(_.isObject(a)) {
        for(var i in a) {
            b[i] = parse(a[i]);
        }
    } else {
        return a;
    }
    //copy b into a
    return b;
}

class keyup {

    constructor() {

        // listen for the "keypress" event
        _.extend(this,{
            _line: [],
            _lines: [""],
            _events: {},
            _commands: {},
            _lastKey: null,
            _currentKey: null,
            _currentLine: 0,
            _buffer: [],
            _running:false,
            _cursor: 0,
            _questions: [],
            _asking: false,
            _prefix: "",
            _print: false,
            _input: false,
            _flag: "-",
            _color: "white",
            _escape: ["ctrl+c","escape"],
            _commandline: true,
        });
        process.stdin.on('keypress', (ch,k) => {
            // console.log(`key ${key} ${ch}`)
            var name = k ? ['ctrl','shift','meta'].map(a => k[a] ? a+'+':'').join('') + k.name : ch;

            var key = k ? k.sequence : ch;

            if(this._escape.indexOf(name) !== -1) {
                return this.eventEnd();
            }
            this.add({name,key});
            // this.keypress(ch,key);
        });
        process.stdin.setRawMode(true);

    }

    add(key) {
        this._buffer.push(key);
        if(!this._running) {
            this._running = true;
            this.keypress();
        }
    }

    prefix(prefix) {
        this._prefix = prefix+' ';
        return this;
    }

    color(color) {
        color = color.toLowerCase().trim();
        if(colorList.indexOf(color) !== -1) {
            this._color = color;
        } else {
            console.log(`keyup.color error ${color} not recognised`);
        }
        return this;
    }

    command(command) {
        if(_.isObject(command)) this._commands = parse(command);
    }

    on(event,callback) {
        var eventList = event.trim().split(/[:, ]/).filter(a => a != "");
        var eventName = eventList[0];
        var args = eventList.slice(1);
        // console.log(`args ${json(args)}`);
        if(this._events.hasOwnProperty(eventName)) {
            this._events[eventName].push({args,callback});
        } else {
            this._events[eventName] = [{args,callback}];
        }
        return this;
    }

    stop() {
        process.stdin.pause();
        // this._print = false;
        this._input = false;
        return this;
    }

    start() {
        process.stdin.resume();
        this._print = true;
        this._input = true;
        return this;
    }

    write(text) {
        if(this._print || this._asking) process.stdout.write(colors[this._color](text));
        return this;
    }

    eventEnd() {
        this.runEvent('exit',{})
        this.stop();
    }

    ask(question,callback) {
        if(!this._input) process.stdin.resume();
        if(callback && _.isFunction(callback)) {
            this._questions.push({question,callback});
            if(!this._asking) {
                this.startQuestions();
            }
            return this;
        } else {
            // console.log('creating promise');
            return new Promise(resolve => {
                this._questions.push({question,callback:resolve});
                if(!this._asking) {
                    this.startQuestions();
                }
            })
        }
    }

    startQuestions() {
        if(this._questions.length === 0) return;
        this._asking = true;
        if(this._line.length > 0) this.write('\r\n');
        this.askQuestion();
    }

    askQuestion() {
        this.write(this._questions[0].question+' ');
    }

    eventQuestion(data) {
        if(this._questions.length === 0 || !_.isFunction(this._questions[0].callback)) {
            return Promise.resolve(data);
        }
        var res;
        try {
            res = this._questions[0].callback(data);
        } catch(e) {
            console.error(`keyup: question ${name} callback error ${e}`);
        }
        this._questions = this._questions.slice(1);
        return Promise.resolve(res).then(r => {
            if(this._questions.length === 0) {
                this._asking = false;
                if(!this._input) {
                    this.stop();
                }
            } else {
                this.askQuestion();
            }
        });
    }

    runEvent(name,data,num) {

        // if(this._events[name] && this._events[name].length) {
        //     // console.log(`running event ${name}`);
        //     this._events[name].forEach(event => {
        //         try {
        //             var res = event.callback(data);
        //             if(_.isString(res)) {
        //                 data.sequence = res;
        //             } else if(_.isObject(res)) {
        //                 ['name','line','sequence'].forEach(a => {
        //                     if(res.hasOwnProperty(a)) data[a] = res[a];
        //                 });
        //             }
        //         } catch(e) {
        //             console.error(`keyup: on.${name} callback error ${e}`);
        //         }
        //     });
        // } else {
        //     // console.log(`no event ${name} ${json(this._events[name])}`);
        //     // return Promise.resolve(data);
        // }
        // return data;

        // Proposed promisey events

        num = num || 0;

        if(this._events[name] && this._events[name].length > num) {
            // console.log(`running event ${name}`);
            // return promiseQueue(this._events[name],data);
            var event = this._events[name][num];
            var input = _.isObject(data) && data[name] ? data[name] : data;
            var r;
            if(event.args && event.args.length) {
                if(event.args.length === 1 && _.isString(input)) {
                    if(input == event.args[0]) r = event.callback(data);
                } else if(_.isArray(input) && _.every(event.args,(e,i) => input[i] == e)) {
                    r = event.callback(input.slice(event.args.length));
                }
            } else {
                r = event.callback(data);
            }
            return Promise.resolve(r)
                .then(res => {
                    if(_.isObject(data)) {
                        if(_.isObject(res)) {
                            _.extend(data,res);
                        } else if(_.isString(res)) {
                            data[name] = res;
                        }
                    } else if(_.isString(data)) {
                        if(_.isObject(res) && res[name]) {
                            data = res[name]
                        } else if(_.isString(res)) {
                            data = res;
                        }
                    }
                    return this.runEvent(name,data,num+1);
                });
        } else {
            return Promise.resolve(data);
        }

    }

    pause() {
        this._paused = true;
    }

    resume() {
        this._paused = false;
    }

    insert(text) {
        var list = text.split('');
        this._line = this._line.slice(0,this._cursor).concat(list).concat(this._line.slice(this._cursor));
        // this.write(rewriteText(this._line.slice(this._cursor).join('')));
        this._cursor += list.length;

    }

    eventKey(key) {
        // key = this.runEvent(key.name,key);
        // key = this.runEvent('key',key);
        // return key;
        return this.runEvent('key',key);
    }

    eventLine(line) {

        return this.runEvent('line',line);
    }

    eventCommand(line) {
        var command = splitArgs(line);
        return this.runEvent('command',command);
    }

    addLine(line) {
        this._currentLine = this._lines.length;
        this._lines[this._lines.length-1] = line;
        this._lines.push("");
        this._line = [];
        this._cursor = 0;
        this.write(this._prefix);
    }

    addChar(key) {
        if(key.length === 0) return;
        if(key.length === 1) {
            this._line.splice(this._cursor,0,key);
            // this.write(rewriteText(this._line.slice(this._cursor).join('')));
            this.writeLine();
            this._cursor++;
        } else {
            var list = key.split('');
            this._line = this._line.slice(0,this._cursor).concat(list).concat(this._line.slice(this._cursor));
            // this.write(rewriteText(this._line.slice(this._cursor).join('')));
            this.writeLine();
            this._cursor += list.length;
            this.write(list.map(a => rightChar).slice(1).join(''));

        }

    }

    nextKey() {
        if(this._running) {
            this.keypress();
        }
    }

    keypress() {

        if(!this._input && !this._asking) return;

        if(this._buffer.length === 0) {
            this._running = false;
            return;
        }

        var {key,name} = this._buffer.shift();

        var line = this._line.join('');
        var length = this._line.length;
        // run on.key events

        this.eventKey({key,name,line}).then(afterKey => {
            // console.log(`got through ${json(afterKey)}`)
            switch(afterKey.name) {
                case "return":
                    this.write('\r\n')
                    if(this._asking) {
                        this.eventQuestion(afterKey.line)
                            .then(afterQuestion => {
                                this.addLine(line);
                                this.nextKey();
                            }).catch(console.error);
                    } else {
                        this.eventLine(line)
                            .then(afterLine => this.eventCommand(afterLine))
                            .then(afterCommand => {
                                // console.log(`had line ${json(afterCommand)}`);
                                this.addLine(line)
                                this.nextKey();
                            }).catch(console.error);
                    }
                    return;
                case 'backspace':
                    if(this._cursor > 0) {
                        this._line.splice(this._cursor-1,1);
                        this._cursor--;
                        this.write(leftChar);
                        this.writeLine();
                        this.write(leftChar);
                    }
                    break;
                case 'delete':
                    if(this._cursor < length) {
                        this._line.splice(this._cursor,1);
                        this.writeLine();
                        this.write(leftChar);
                    }
                    break;
                case 'home':
                    this._cursor = 0;
                    this.write("\r"+this._prefix);
                    break;
                case 'end':
                    var distance = length - this._cursor;
                    this._cursor = length;
                    this.write(new Array(distance+1).join(rightChar));
                    break;
                case 'left':
                    if(this._cursor > 0) {
                        this._cursor--;
                        this.write(key);
                    }
                    break;
                case 'right':
                    if(this._cursor < length) {
                        this._cursor++;
                        this.write(key);
                    }
                    break;
                case 'ctrl+left':
                    // if next is gap find non-gap and vice versa
                    var point = this._cursor;
                    if(this._cursor === length) point--;
                    while(point > 0 && !this._line[point].match(/[a-zA-Z0-9]/)) point--;
                    while(point > 0 && this._line[point].match(/[a-zA-Z0-9]/)) point--;
                    this.write(new Array(1+this._cursor-point).join(leftChar));
                    this._cursor = point;
                    break;
                case 'ctrl+right':
                    // if next is gap find non-gap and vice versa
                    var point = this._cursor;
                    while(point < length && !this._line[point].match(/[a-zA-Z0-9]/)) point++;
                    while(point < length && this._line[point].match(/[a-zA-Z0-9]/)) point++;
                    this.write(new Array(1+point-this._cursor).join(rightChar));
                    this._cursor = point;
                    break;

                case "up":
                    //go to previous row
                    if(this._currentLine > 0) {
                        // if bottom line, save before moving
                        if(this._currentLine === this._lines.length-1) {
                            this._lines[this._lines.length-1] = line;
                        }
                        this._currentLine--;
                        var l = this._lines[this._currentLine];
                        var txt = rewriteLine(line, l);
                        // console.log(`rewrite ${this._currentLine} : ${this._lines.length} : ${l} ${json(txt)}`);
                        this.write( txt );
                        // key = wipe + l;
                        this._line = l.split('');
                        this._cursor = l.length;
                    }
                    break;
                    case "down":
                        if(this._currentLine < this._lines.length-1) {
                            this._currentLine++;
                            var l = this._lines[this._currentLine];
                            // console.log(`down ${this._currentLine} : ${this._lines.length} : ${json(l)}`);
                            //key = wipe + l;
                            this.write( rewriteLine(line,l) );
                            this._line = l.split('');
                            this._cursor = l.length;
                        } else {
                            // console.log(`blank ${this._currentLine} : ${this._lines.length}`);
                            // if(this._currentLine == this._lines.length-1) {
                            if(line.length) {
                                this._lines[this._lines.length-1] = line;
                            }
                            this._currentLine = this._lines.length;
                            this.write( rewriteLine(line,"") );
                            this._line = [];
                            this._cursor = 0;
                        }
                        break;
                    default:
                        // normal characters(? no tab yet)
                        // this._line.splice(this._cursor,0,key);
                        // this.write(rewriteText(this._line.slice(this._cursor).join('')));
                        // this.writeLine();
                        // this._cursor++;
                        // this.write(key);
                        this.addChar(afterKey.key);
                }
                this._lastKey = this._currentKey;
                this.nextKey();
            }).catch(console.error);
    }

    runCommandLine(line,next,name,sequence) {
        this._currentKey = next.name;

        if(!this._commandline) {
            this.write(next.sequence);
            if(name == 'return') {
                this.eventLine(line);
                // var command = splitArgs(line);

                this._currentLine = this._lines.length;
                this._lines[this._lines.length-1] = line;
                this._lines.push("");
                this._line = [];
                this._cursor = 0;
            } else {
                this._line.push(next.sequence);
                this._cursor++;
            }
            return;
        }

        if(sequence !== next.sequence) {
            // console.log(`different ${next.sequence}`);
            // this.insert(next.sequence);
            var list = next.sequence.split('');
            this._line = this._line.slice(0,this._cursor).concat(list).concat(this._line.slice(this._cursor));
            // this.write(rewriteText(this._line.slice(this._cursor).join('')));
            this.writeLine();
            this._cursor += list.length;
            this.write(list.map(a => rightChar).slice(1).join(''));
            // this._line.splice(this._cursor,0,next.sequence);
            // this.write(rewriteText(this._line.slice(this._cursor).join('')));
            // this._cursor += next.sequence.length;
            return;
        } else {
            switch(name) {
                case 'tab':
                    var left = line.slice(0,this._cursor);
                    var suggestion = this.suggest(left);
                    if(suggestion.length) {
                        this._line = (left+suggestion).split('');
                        this._cursor = length;
                        this.write( rewriteLine(line,left+suggestion) )
                    }
                    break;
                case 'return':
                    this.write('\r\n');

                    if(this._asking) {
                        this.eventQuestion(line);
                    } else {
                        this.eventLine(line);
                        this.eventCommand(line);
                        // var command = splitArgs(line);
                        // this.runEvent('command',command);
                        this._currentLine = this._lines.length;
                        this._lines[this._lines.length-1] = line;
                        this._lines.push("");
                    }
                    this._line = [];
                    this._cursor = 0;
                    break;
                case 'backspace':
                    if(this._cursor > 0) {
                        this._line.splice(this._cursor-1,1);
                        this._cursor--;
                        this.write(leftChar);
                        this.writeLine();
                        this.write(leftChar);
                    }
                    break;
                case 'delete':
                    if(this._cursor < length) {
                        this._line.splice(this._cursor,1);
                        this.writeLine();
                        this.write(leftChar);
                    }
                    break;
                case 'home':
                    this._cursor = 0;
                    this.write("\r");
                    break;
                case 'end':
                    var distance = length - this._cursor;
                    this._cursor = length;
                    this.write(new Array(distance+1).join(rightChar));
                    break;
                case 'left':
                    if(this._cursor > 0) {
                        this._cursor--;
                        this.write(sequence);
                    }
                    break;
                case 'right':
                    if(this._cursor < length) {
                        this._cursor++;
                        this.write(sequence);
                    }
                    break;
                case 'ctrl+left':
                    // if next is gap find non-gap and vice versa
                    var point = this._cursor;
                    if(this._cursor === length) point--;
                    while(point > 0 && !this._line[point].match(/[a-zA-Z0-9]/)) point--;
                    while(point > 0 && this._line[point].match(/[a-zA-Z0-9]/)) point--;
                    this.write(new Array(1+this._cursor-point).join(leftChar));
                    this._cursor = point;
                    break;
                case 'ctrl+right':
                    // if next is gap find non-gap and vice versa
                    var point = this._cursor;
                    while(point < length && !this._line[point].match(/[a-zA-Z0-9]/)) point++;
                    while(point < length && this._line[point].match(/[a-zA-Z0-9]/)) point++;
                    this.write(new Array(1+point-this._cursor).join(rightChar));
                    this._cursor = point;
                    break;

                case "up":
                    //go to previous row
                    if(this._currentLine > 0) {
                        // if bottom line, save before moving
                        if(this._currentLine === this._lines.length-1) {
                            this._lines[this._lines.length-1] = line;
                        }
                        this._currentLine--;
                        var l = this._lines[this._currentLine];
                        var txt = rewriteLine(line, l);
                        // console.log(`rewrite ${this._currentLine} : ${this._lines.length} : ${l} ${json(txt)}`);
                        this.write( txt );
                        // sequence = wipe + l;
                        this._line = l.split('');
                        this._cursor = l.length;
                    }
                    break;
                case "down":
                    if(this._currentLine < this._lines.length-1) {
                        this._currentLine++;
                        var l = this._lines[this._currentLine];
                        // console.log(`down ${this._currentLine} : ${this._lines.length} : ${json(l)}`);
                        //sequence = wipe + l;
                        this.write( rewriteLine(line,l) );
                        this._line = l.split('');
                        this._cursor = l.length;
                    } else {
                        // console.log(`blank ${this._currentLine} : ${this._lines.length}`);
                        // if(this._currentLine == this._lines.length-1) {
                        if(line.length) {
                            this._lines[this._lines.length-1] = line;
                        }
                        this._currentLine = this._lines.length;
                        this.write( rewriteLine(line,"") );
                        this._line = [];
                        this._cursor = 0;
                    }
                    break;
                default:
                    // normal characters(? no tab yet)
                    this._line.splice(this._cursor,0,sequence);
                    // this.write(rewriteText(this._line.slice(this._cursor).join('')));
                    this.writeLine();
                    this._cursor++;
                    // this.write(sequence);
            }
        }
        this._lastKey = this._currentKey;
        if(this._running) {
            this.keypress();
        }
    }

    writeLine() {
        this.write(rewriteText(this._line.slice(this._cursor).join('')+' '));
    }

    suggest(line) {

        // console.log(`got line ${json(line)} ${this._lastKey}`);
        var list = line.split(' ');
        var end = list.length-1;
        var commands = this.check(list.slice(0,end));
        if(_.isBoolean(commands)) {
            // console.log('commands are boolean '+commands);
            return "";
        } else {
            // console.log(`commands ${json(commands)}`);
        }
        var last = '^'+escapeRegExp(list[end]);
        var lastReg = new RegExp(last,'i');
        // console.log('last '+last);
        // for(var i=0;i<end;i++) {
        //     try {
        //         commands = commands[list[i]];
        //     } catch(e) {
        //         return "";
        //     }
        // }

        var options = _.keys(commands);

        var matching = options.filter(c => c.match(lastReg));
        var matchingLength = matching.length;

        if(matchingLength) {
            if(matchingLength === 1) {
                return matching[0].replace(lastReg,'') + ' ';
            } else {
                var matchLengths = matching.map(a => a.length);
                var minLength = _.min(matchLengths);
                var count = 0;
                for(var i=0;i<minLength;i++) {
                    var currentVal = matching[0][i];
                    if(!_.every(matching,m => m[i] == currentVal)) break;
                    count++;
                }
                var added = matching[0].slice(0,count).replace(lastReg,'');
                if(added.length) return added;
                if(this._lastKey == 'tab') {
                    console.log(`\n${matching.join(' ')}`);
                    this.write(this._prefix+line);
                    this._currentKey == 'shown tab';
                } else {
                    // console.log(`got options ${matching.join(', ')}`);
                    // this.write(line);
                }
            }
        } else {
            // console.log(`no options ${options.join(', ')}`);
            // this.write(line);
        }

        return "";
    }

}

module.exports = new keyup();
