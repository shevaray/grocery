import { Directive, ElementRef, Input, Renderer2 } from '@angular/core';
import { alreadyHasAThemeSuffix, getNameAndNamespace, isIconDefinition, warn, withSuffix } from '../utils';
import { IconService } from './icon.service';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './icon.service';
function checkMeta(prev, after) {
    return prev.type === after.type && prev.theme === after.theme && prev.twoToneColor === after.twoToneColor;
}
export class IconDirective {
    constructor(_iconService, _elementRef, _renderer) {
        this._iconService = _iconService;
        this._elementRef = _elementRef;
        this._renderer = _renderer;
    }
    ngOnChanges(changes) {
        if (changes.type || changes.theme || changes.twoToneColor) {
            this._changeIcon();
        }
    }
    /**
     * Render a new icon in the current element. Remove the icon when `type` is falsy.
     */
    _changeIcon() {
        return new Promise(resolve => {
            if (!this.type) {
                this._clearSVGElement();
                resolve(null);
            }
            else {
                const preMeta = this._getSelfRenderMeta();
                this._iconService.getRenderedContent(this._parseIconType(this.type, this.theme), this.twoToneColor).subscribe(svg => {
                    // avoid race condition, see https://github.com/ant-design/ant-design-icons/issues/315
                    if (checkMeta(preMeta, this._getSelfRenderMeta())) {
                        this._setSVGElement(svg);
                        resolve(svg);
                    }
                    else {
                        resolve(null);
                    }
                });
            }
        });
    }
    _getSelfRenderMeta() {
        return {
            type: this.type,
            theme: this.theme,
            twoToneColor: this.twoToneColor
        };
    }
    /**
     * Parse a icon to the standard form, an `IconDefinition` or a string like 'account-book-fill` (with a theme suffixed).
     * If namespace is specified, ignore theme because it meaningless for users' icons.
     *
     * @param type
     * @param theme
     */
    _parseIconType(type, theme) {
        if (isIconDefinition(type)) {
            return type;
        }
        else {
            const [name, namespace] = getNameAndNamespace(type);
            if (namespace) {
                return type;
            }
            if (alreadyHasAThemeSuffix(name)) {
                if (!!theme) {
                    warn(`'type' ${name} already gets a theme inside so 'theme' ${theme} would be ignored`);
                }
                return name;
            }
            else {
                return withSuffix(name, theme || this._iconService.defaultTheme);
            }
        }
    }
    _setSVGElement(svg) {
        this._clearSVGElement();
        this._renderer.appendChild(this._elementRef.nativeElement, svg);
    }
    _clearSVGElement() {
        var _a;
        const el = this._elementRef.nativeElement;
        const children = el.childNodes;
        const length = children.length;
        for (let i = length - 1; i >= 0; i--) {
            const child = children[i];
            if (((_a = child.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'svg') {
                this._renderer.removeChild(el, child);
            }
        }
    }
}
IconDirective.ɵfac = function IconDirective_Factory(t) { return new (t || IconDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.IconService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
IconDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IconDirective, selectors: [["", "antIcon", ""]], inputs: { type: "type", theme: "theme", twoToneColor: "twoToneColor" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
IconDirective.ctorParameters = () => [
    { type: IconService },
    { type: ElementRef },
    { type: Renderer2 }
];
IconDirective.propDecorators = {
    type: [{ type: Input }],
    theme: [{ type: Input }],
    twoToneColor: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IconDirective, [{
        type: Directive,
        args: [{
                selector: '[antIcon]'
            }]
    }], function () { return [{ type: ɵngcc1.IconService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { type: [{
            type: Input
        }], theme: [{
            type: Input
        }], twoToneColor: [{
            type: Input
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWNvbi5kaXJlY3RpdmUuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnQvaWNvbi5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxVQUFVLEVBQ1YsS0FBSyxFQUVMLFNBQVMsRUFFVixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsc0JBQXNCLEVBQUUsbUJBQW1CLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUMzRyxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7OztBQVE3QyxTQUFTLFNBQVMsQ0FBQyxJQUFnQixFQUFFLEtBQWlCO0FBQUksSUFDeEQsT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLEtBQUssQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLEtBQUssS0FBSyxLQUFLLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxZQUFZLEtBQUssS0FBSyxDQUFDLFlBQVksQ0FBQztBQUM1RyxDQUFDO0FBS0QsTUFBTSxPQUFPLGFBQWE7QUFBRyxJQUszQixZQUFzQixZQUF5QixFQUFZLFdBQXVCLEVBQVksU0FBb0I7QUFBSSxRQUFoRyxpQkFBWSxHQUFaLFlBQVksQ0FBYTtBQUFDLFFBQVcsZ0JBQVcsR0FBWCxXQUFXLENBQVk7QUFBQyxRQUFXLGNBQVMsR0FBVCxTQUFTLENBQVc7QUFBQyxJQUFFLENBQUM7QUFDeEgsSUFDRSxXQUFXLENBQUMsT0FBc0I7QUFBSSxRQUNwQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLEtBQUssSUFBSSxPQUFPLENBQUMsWUFBWSxFQUFFO0FBQy9ELFlBQU0sSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0FBQ3pCLFNBQUs7QUFDTCxJQUFFLENBQUM7QUFDSCxJQUNFO0FBQ0Y7QUFDRSxPQUFHO0FBQ0wsSUFBWSxXQUFXO0FBQUssUUFDeEIsT0FBTyxJQUFJLE9BQU8sQ0FBb0IsT0FBTyxDQUFDLEVBQUU7QUFDcEQsWUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRTtBQUN0QixnQkFBUSxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztBQUNoQyxnQkFBUSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDdEIsYUFBTztBQUFDLGlCQUFLO0FBQ2IsZ0JBQVEsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7QUFDbEQsZ0JBQVEsSUFBSSxDQUFDLFlBQVksQ0FBQyxrQkFBa0IsQ0FDbEMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsRUFDMUMsSUFBSSxDQUFDLFlBQVksQ0FDbEIsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLEVBQUU7QUFDMUIsb0JBQVUsc0ZBQXNGO0FBQ2hHLG9CQUFVLElBQUksU0FBUyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQyxFQUFFO0FBQzdELHdCQUFZLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDckMsd0JBQVksT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3pCLHFCQUFXO0FBQUMseUJBQUs7QUFDakIsd0JBQVksT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzFCLHFCQUFXO0FBQ1gsZ0JBQVEsQ0FBQyxDQUFDLENBQUM7QUFDWCxhQUFPO0FBQ1AsUUFBSSxDQUFDLENBQUMsQ0FBQztBQUNQLElBQUUsQ0FBQztBQUNILElBQ1ksa0JBQWtCO0FBQUssUUFDL0IsT0FBTztBQUNYLFlBQU0sSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO0FBQ3JCLFlBQU0sS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLO0FBQ3ZCLFlBQU0sWUFBWSxFQUFFLElBQUksQ0FBQyxZQUFZO0FBQ3JDLFNBQUssQ0FBQztBQUNOLElBQUUsQ0FBQztBQUNILElBQ0U7QUFDRjtBQUNFO0FBQ0U7QUFDRTtBQUNFO0FBRUosT0FEQztBQUNMLElBQVksY0FBYyxDQUFDLElBQTZCLEVBQUUsS0FBZ0I7QUFBSSxRQUMxRSxJQUFJLGdCQUFnQixDQUFDLElBQUksQ0FBQyxFQUFFO0FBQ2hDLFlBQU0sT0FBTyxJQUFJLENBQUM7QUFDbEIsU0FBSztBQUFDLGFBQUs7QUFDWCxZQUFNLE1BQU0sQ0FBRSxJQUFJLEVBQUUsU0FBUyxDQUFFLEdBQUcsbUJBQW1CLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDNUQsWUFBTSxJQUFJLFNBQVMsRUFBRTtBQUNyQixnQkFBUSxPQUFPLElBQUksQ0FBQztBQUNwQixhQUFPO0FBQ1AsWUFBTSxJQUFJLHNCQUFzQixDQUFDLElBQUksQ0FBQyxFQUFFO0FBQ3hDLGdCQUFRLElBQUksQ0FBQyxDQUFDLEtBQUssRUFBRTtBQUNyQixvQkFBVSxJQUFJLENBQUMsVUFBVSxJQUFJLDJDQUEyQyxLQUFLLG1CQUFtQixDQUFDLENBQUM7QUFDbEcsaUJBQVM7QUFDVCxnQkFBUSxPQUFPLElBQUksQ0FBQztBQUNwQixhQUFPO0FBQUMsaUJBQUs7QUFDYixnQkFBUSxPQUFPLFVBQVUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDekUsYUFBTztBQUNQLFNBQUs7QUFDTCxJQUFFLENBQUM7QUFDSCxJQUNZLGNBQWMsQ0FBQyxHQUFlO0FBQUksUUFDMUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7QUFDNUIsUUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUNwRSxJQUFFLENBQUM7QUFDSCxJQUNZLGdCQUFnQjtBQUFLO0FBQ3ZCLFFBQU4sTUFBTSxFQUFFLEdBQWdCLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDO0FBQzNELFFBQUksTUFBTSxRQUFRLEdBQUcsRUFBRSxDQUFDLFVBQVUsQ0FBQztBQUNuQyxRQUFJLE1BQU0sTUFBTSxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUM7QUFDbkMsUUFBSSxLQUFLLElBQUksQ0FBQyxHQUFHLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUMxQyxZQUFNLE1BQU0sS0FBSyxHQUFHLFFBQVEsQ0FBRSxDQUFDLENBQVMsQ0FBQztBQUN6QyxZQUFNLElBQUksQ0FBQSxNQUFBLEtBQUssQ0FBQyxPQUFPLDBDQUFFLFdBQVcsRUFBRSxNQUFLLEtBQUssRUFBRTtBQUNsRCxnQkFBUSxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDOUMsYUFBTztBQUNQLFNBQUs7QUFDTCxJQUFFLENBQUM7QUFDSDt5Q0E1RkMsU0FBUyxTQUFDLGtCQUNULFFBQVEsRUFBRSxXQUFXLGNBQ3RCOzBOQUNJO0FBQUM7QUFBdUMsWUFmcEMsV0FBVztBQUFJLFlBUnRCLFVBQVU7QUFDVixZQUVBLFNBQVM7QUFDVjtBQUFHO0FBQ2lCLG1CQW1CbEIsS0FBSztBQUFLLG9CQUNWLEtBQUs7QUFBSywyQkFDVixLQUFLO0FBQUk7Ozs7Ozs7Ozs7OztvQkFBRTtBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBJbnB1dCxcbiAgT25DaGFuZ2VzLFxuICBSZW5kZXJlcjIsXG4gIFNpbXBsZUNoYW5nZXNcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJY29uRGVmaW5pdGlvbiwgVGhlbWVUeXBlIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgYWxyZWFkeUhhc0FUaGVtZVN1ZmZpeCwgZ2V0TmFtZUFuZE5hbWVzcGFjZSwgaXNJY29uRGVmaW5pdGlvbiwgd2Fybiwgd2l0aFN1ZmZpeCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IEljb25TZXJ2aWNlIH0gZnJvbSAnLi9pY29uLnNlcnZpY2UnO1xuXG5pbnRlcmZhY2UgUmVuZGVyTWV0YSB7XG4gIHR5cGU6IHN0cmluZyB8IEljb25EZWZpbml0aW9uO1xuICB0aGVtZTogVGhlbWVUeXBlO1xuICB0d29Ub25lQ29sb3I6IHN0cmluZztcbn1cblxuZnVuY3Rpb24gY2hlY2tNZXRhKHByZXY6IFJlbmRlck1ldGEsIGFmdGVyOiBSZW5kZXJNZXRhKTogYm9vbGVhbiB7XG4gIHJldHVybiBwcmV2LnR5cGUgPT09IGFmdGVyLnR5cGUgJiYgcHJldi50aGVtZSA9PT0gYWZ0ZXIudGhlbWUgJiYgcHJldi50d29Ub25lQ29sb3IgPT09IGFmdGVyLnR3b1RvbmVDb2xvcjtcbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2FudEljb25dJ1xufSlcbmV4cG9ydCBjbGFzcyBJY29uRGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgdHlwZTogc3RyaW5nIHwgSWNvbkRlZmluaXRpb247XG4gIEBJbnB1dCgpIHRoZW1lOiBUaGVtZVR5cGU7XG4gIEBJbnB1dCgpIHR3b1RvbmVDb2xvcjogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBfaWNvblNlcnZpY2U6IEljb25TZXJ2aWNlLCBwcm90ZWN0ZWQgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHByb3RlY3RlZCBfcmVuZGVyZXI6IFJlbmRlcmVyMikge31cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgaWYgKGNoYW5nZXMudHlwZSB8fCBjaGFuZ2VzLnRoZW1lIHx8IGNoYW5nZXMudHdvVG9uZUNvbG9yKSB7XG4gICAgICB0aGlzLl9jaGFuZ2VJY29uKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIG5ldyBpY29uIGluIHRoZSBjdXJyZW50IGVsZW1lbnQuIFJlbW92ZSB0aGUgaWNvbiB3aGVuIGB0eXBlYCBpcyBmYWxzeS5cbiAgICovXG4gIHByb3RlY3RlZCBfY2hhbmdlSWNvbigpOiBQcm9taXNlPFNWR0VsZW1lbnQgfCBudWxsPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPFNWR0VsZW1lbnQgfCBudWxsPihyZXNvbHZlID0+IHtcbiAgICAgIGlmICghdGhpcy50eXBlKSB7XG4gICAgICAgIHRoaXMuX2NsZWFyU1ZHRWxlbWVudCgpO1xuICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcHJlTWV0YSA9IHRoaXMuX2dldFNlbGZSZW5kZXJNZXRhKCk7XG4gICAgICAgIHRoaXMuX2ljb25TZXJ2aWNlLmdldFJlbmRlcmVkQ29udGVudChcbiAgICAgICAgICB0aGlzLl9wYXJzZUljb25UeXBlKHRoaXMudHlwZSwgdGhpcy50aGVtZSksXG4gICAgICAgICAgdGhpcy50d29Ub25lQ29sb3JcbiAgICAgICAgKS5zdWJzY3JpYmUoc3ZnID0+IHtcbiAgICAgICAgICAvLyBhdm9pZCByYWNlIGNvbmRpdGlvbiwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnQtZGVzaWduL2FudC1kZXNpZ24taWNvbnMvaXNzdWVzLzMxNVxuICAgICAgICAgIGlmIChjaGVja01ldGEocHJlTWV0YSwgdGhpcy5fZ2V0U2VsZlJlbmRlck1ldGEoKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFNWR0VsZW1lbnQoc3ZnKTtcbiAgICAgICAgICAgIHJlc29sdmUoc3ZnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9nZXRTZWxmUmVuZGVyTWV0YSgpOiBSZW5kZXJNZXRhIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgdGhlbWU6IHRoaXMudGhlbWUsXG4gICAgICB0d29Ub25lQ29sb3I6IHRoaXMudHdvVG9uZUNvbG9yXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIGljb24gdG8gdGhlIHN0YW5kYXJkIGZvcm0sIGFuIGBJY29uRGVmaW5pdGlvbmAgb3IgYSBzdHJpbmcgbGlrZSAnYWNjb3VudC1ib29rLWZpbGxgICh3aXRoIGEgdGhlbWUgc3VmZml4ZWQpLlxuICAgKiBJZiBuYW1lc3BhY2UgaXMgc3BlY2lmaWVkLCBpZ25vcmUgdGhlbWUgYmVjYXVzZSBpdCBtZWFuaW5nbGVzcyBmb3IgdXNlcnMnIGljb25zLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZVxuICAgKiBAcGFyYW0gdGhlbWVcbiAgICovXG4gIHByb3RlY3RlZCBfcGFyc2VJY29uVHlwZSh0eXBlOiBzdHJpbmcgfCBJY29uRGVmaW5pdGlvbiwgdGhlbWU6IFRoZW1lVHlwZSk6IEljb25EZWZpbml0aW9uIHwgc3RyaW5nIHtcbiAgICBpZiAoaXNJY29uRGVmaW5pdGlvbih0eXBlKSkge1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFsgbmFtZSwgbmFtZXNwYWNlIF0gPSBnZXROYW1lQW5kTmFtZXNwYWNlKHR5cGUpO1xuICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICAgIGlmIChhbHJlYWR5SGFzQVRoZW1lU3VmZml4KG5hbWUpKSB7XG4gICAgICAgIGlmICghIXRoZW1lKSB7XG4gICAgICAgICAgd2FybihgJ3R5cGUnICR7bmFtZX0gYWxyZWFkeSBnZXRzIGEgdGhlbWUgaW5zaWRlIHNvICd0aGVtZScgJHt0aGVtZX0gd291bGQgYmUgaWdub3JlZGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHdpdGhTdWZmaXgobmFtZSwgdGhlbWUgfHwgdGhpcy5faWNvblNlcnZpY2UuZGVmYXVsdFRoZW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX3NldFNWR0VsZW1lbnQoc3ZnOiBTVkdFbGVtZW50KTogdm9pZCB7XG4gICAgdGhpcy5fY2xlYXJTVkdFbGVtZW50KCk7XG4gICAgdGhpcy5fcmVuZGVyZXIuYXBwZW5kQ2hpbGQodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBzdmcpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9jbGVhclNWR0VsZW1lbnQoKTogdm9pZCB7XG4gICAgY29uc3QgZWw6IEhUTUxFbGVtZW50ID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIGNvbnN0IGNoaWxkcmVuID0gZWwuY2hpbGROb2RlcztcbiAgICBjb25zdCBsZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuWyBpIF0gYXMgYW55O1xuICAgICAgaWYgKGNoaWxkLnRhZ05hbWU/LnRvTG93ZXJDYXNlKCkgPT09ICdzdmcnKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUNoaWxkKGVsLCBjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXX0=