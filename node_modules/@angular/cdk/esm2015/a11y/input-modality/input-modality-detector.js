/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ALT, CONTROL, MAC_META, META, SHIFT } from '@angular/cdk/keycodes';
import { Inject, Injectable, InjectionToken, Optional, NgZone } from '@angular/core';
import { normalizePassiveListenerOptions, Platform, _getEventTarget } from '@angular/cdk/platform';
import { DOCUMENT } from '@angular/common';
import { BehaviorSubject } from 'rxjs';
import { distinctUntilChanged, skip } from 'rxjs/operators';
import { isFakeMousedownFromScreenReader, isFakeTouchstartFromScreenReader, } from '../fake-event-detection';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/platform";
import * as i2 from "@angular/common";
/**
 * Injectable options for the InputModalityDetector. These are shallowly merged with the default
 * options.
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/cdk/platform';
export const INPUT_MODALITY_DETECTOR_OPTIONS = new InjectionToken('cdk-input-modality-detector-options');
/**
 * Default options for the InputModalityDetector.
 *
 * Modifier keys are ignored by default (i.e. when pressed won't cause the service to detect
 * keyboard input modality) for two reasons:
 *
 * 1. Modifier keys are commonly used with mouse to perform actions such as 'right click' or 'open
 *    in new tab', and are thus less representative of actual keyboard interaction.
 * 2. VoiceOver triggers some keyboard events when linearly navigating with Control + Option (but
 *    confusingly not with Caps Lock). Thus, to have parity with other screen readers, we ignore
 *    these keys so as to not update the input modality.
 *
 * Note that we do not by default ignore the right Meta key on Safari because it has the same key
 * code as the ContextMenu key on other browsers. When we switch to using event.key, we can
 * distinguish between the two.
 */
export const INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS = {
    ignoreKeys: [ALT, CONTROL, MAC_META, META, SHIFT],
};
/**
 * The amount of time needed to pass after a touchstart event in order for a subsequent mousedown
 * event to be attributed as mouse and not touch.
 *
 * This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found
 * that a value of around 650ms seems appropriate.
 */
export const TOUCH_BUFFER_MS = 650;
/**
 * Event listener options that enable capturing and also mark the listener as passive if the browser
 * supports it.
 */
const modalityEventListenerOptions = normalizePassiveListenerOptions({
    passive: true,
    capture: true,
});
/**
 * Service that detects the user's input modality.
 *
 * This service does not update the input modality when a user navigates with a screen reader
 * (e.g. linear navigation with VoiceOver, object navigation / browse mode with NVDA, virtual PC
 * cursor mode with JAWS). This is in part due to technical limitations (i.e. keyboard events do not
 * fire as expected in these modes) but is also arguably the correct behavior. Navigating with a
 * screen reader is akin to visually scanning a page, and should not be interpreted as actual user
 * input interaction.
 *
 * When a user is not navigating but *interacting* with a screen reader, this service attempts to
 * update the input modality to keyboard, but in general this service's behavior is largely
 * undefined.
 */
export class InputModalityDetector {
    constructor(_platform, ngZone, document, options) {
        this._platform = _platform;
        /**
         * The most recently detected input modality event target. Is null if no input modality has been
         * detected or if the associated event target is null for some unknown reason.
         */
        this._mostRecentTarget = null;
        /** The underlying BehaviorSubject that emits whenever an input modality is detected. */
        this._modality = new BehaviorSubject(null);
        /**
         * The timestamp of the last touch input modality. Used to determine whether mousedown events
         * should be attributed to mouse or touch.
         */
        this._lastTouchMs = 0;
        /**
         * Handles keydown events. Must be an arrow function in order to preserve the context when it gets
         * bound.
         */
        this._onKeydown = (event) => {
            var _a, _b;
            // If this is one of the keys we should ignore, then ignore it and don't update the input
            // modality to keyboard.
            if ((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.ignoreKeys) === null || _b === void 0 ? void 0 : _b.some(keyCode => keyCode === event.keyCode)) {
                return;
            }
            this._modality.next('keyboard');
            this._mostRecentTarget = _getEventTarget(event);
        };
        /**
         * Handles mousedown events. Must be an arrow function in order to preserve the context when it
         * gets bound.
         */
        this._onMousedown = (event) => {
            // Touches trigger both touch and mouse events, so we need to distinguish between mouse events
            // that were triggered via mouse vs touch. To do so, check if the mouse event occurs closely
            // after the previous touch event.
            if (Date.now() - this._lastTouchMs < TOUCH_BUFFER_MS) {
                return;
            }
            // Fake mousedown events are fired by some screen readers when controls are activated by the
            // screen reader. Attribute them to keyboard input modality.
            this._modality.next(isFakeMousedownFromScreenReader(event) ? 'keyboard' : 'mouse');
            this._mostRecentTarget = _getEventTarget(event);
        };
        /**
         * Handles touchstart events. Must be an arrow function in order to preserve the context when it
         * gets bound.
         */
        this._onTouchstart = (event) => {
            // Same scenario as mentioned in _onMousedown, but on touch screen devices, fake touchstart
            // events are fired. Again, attribute to keyboard input modality.
            if (isFakeTouchstartFromScreenReader(event)) {
                this._modality.next('keyboard');
                return;
            }
            // Store the timestamp of this touch event, as it's used to distinguish between mouse events
            // triggered via mouse vs touch.
            this._lastTouchMs = Date.now();
            this._modality.next('touch');
            this._mostRecentTarget = _getEventTarget(event);
        };
        this._options = Object.assign(Object.assign({}, INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS), options);
        // Skip the first emission as it's null.
        this.modalityDetected = this._modality.pipe(skip(1));
        this.modalityChanged = this.modalityDetected.pipe(distinctUntilChanged());
        // If we're not in a browser, this service should do nothing, as there's no relevant input
        // modality to detect.
        if (!_platform.isBrowser) {
            return;
        }
        // Add the event listeners used to detect the user's input modality.
        ngZone.runOutsideAngular(() => {
            document.addEventListener('keydown', this._onKeydown, modalityEventListenerOptions);
            document.addEventListener('mousedown', this._onMousedown, modalityEventListenerOptions);
            document.addEventListener('touchstart', this._onTouchstart, modalityEventListenerOptions);
        });
    }
    /** The most recently detected input modality. */
    get mostRecentModality() {
        return this._modality.value;
    }
    ngOnDestroy() {
        if (!this._platform.isBrowser) {
            return;
        }
        document.removeEventListener('keydown', this._onKeydown, modalityEventListenerOptions);
        document.removeEventListener('mousedown', this._onMousedown, modalityEventListenerOptions);
        document.removeEventListener('touchstart', this._onTouchstart, modalityEventListenerOptions);
    }
}
InputModalityDetector.ɵfac = function InputModalityDetector_Factory(t) { return new (t || InputModalityDetector)(ɵngcc0.ɵɵinject(ɵngcc1.Platform), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(INPUT_MODALITY_DETECTOR_OPTIONS, 8)); };
InputModalityDetector.ɵprov = i0.ɵɵdefineInjectable({ factory: function InputModalityDetector_Factory() { return new InputModalityDetector(i0.ɵɵinject(i1.Platform), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i2.DOCUMENT), i0.ɵɵinject(INPUT_MODALITY_DETECTOR_OPTIONS, 8)); }, token: InputModalityDetector, providedIn: "root" });
InputModalityDetector.ctorParameters = () => [
    { type: Platform },
    { type: NgZone },
    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [INPUT_MODALITY_DETECTOR_OPTIONS,] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(InputModalityDetector, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: ɵngcc1.Platform }, { type: ɵngcc0.NgZone }, { type: Document, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [INPUT_MODALITY_DETECTOR_OPTIONS]
            }] }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQtbW9kYWxpdHktZGV0ZWN0b3IuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3NyYy9jZGsvYTExeS9pbnB1dC1tb2RhbGl0eS9pbnB1dC1tb2RhbGl0eS1kZXRlY3Rvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBRUgsT0FBTyxFQUFDLEdBQUcsRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUMxRSxPQUFPLEVBQUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxjQUFjLEVBQWEsUUFBUSxFQUFFLE1BQU0sRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUM5RixPQUFPLEVBQUMsK0JBQStCLEVBQUUsUUFBUSxFQUFFLGVBQWUsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBQ2pHLE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSxpQkFBaUIsQ0FBQztBQUN6QyxPQUFPLEVBQUMsZUFBZSxFQUFhLE1BQU0sTUFBTSxDQUFDO0FBQ2pELE9BQU8sRUFBQyxvQkFBb0IsRUFBRSxJQUFJLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUMxRCxPQUFPLEVBQ0wsK0JBQStCLEVBQy9CLGdDQUFnQyxHQUNqQyxNQUFNLHlCQUF5QixDQUFDO0FBQ2pDO0FBRWdDO0FBQTZDO0FBVTdFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUNILE1BQU0sQ0FBQyxNQUFNLCtCQUErQixHQUMxQyxJQUFJLGNBQWMsQ0FBK0IscUNBQXFDLENBQUMsQ0FBQztBQUUxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sdUNBQXVDLEdBQWlDO0FBQ3JGLElBQUUsVUFBVSxFQUFFLENBQUMsR0FBRyxFQUFFLE9BQU8s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SyxRQUN6QixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDO0FBQ2hDLElBQUUsQ0FBQztBQUNILElBZ0dFLFdBQVc7QUFDYixRQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsRUFBRTtBQUFFLFlBQUEsT0FBTztBQUFDLFNBQUM7QUFDOUMsUUFDSSxRQUFRLENBQUMsbUJBQW1CLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxVQUFVLEVBQUUsNEJBQTRCLENBQUMsQ0FBQztBQUMzRixRQUFJLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLFlBQVksRUFBRSw0QkFBNEIsQ0FBQyxDQUFDO0FBQy9GLFFBQUksUUFBUSxDQUFDLG1CQUFtQixDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsYUFBYSxFQUFFLDRCQUE0QixDQUFDLENBQUM7QUFDakcsSUFBRSxDQUFDO0FBQ0g7c1FBQUM7QUFDRCxnVUFuSEs7QUFBQztFQURMLFVBQVUsU0FBQyxFQUFFLHZCQUN1QyxZQWhGWixRQUFRO1NBK0V6QixFQUFFLE1BQU0sRUFBRSxuQkEvRW1CLFlBRFksTUFBTTtBQUFJLFlBbUt6QyxRQUFRLHVCQUFuQyxNQUFNLFNBQUMsUUFBUTtBQUFTLDRDQUN4QixRQUFRLFlBQUksTUFBTSxTQUFDLCtCQUErQjtBQUNuRDs7Ozs7Ozs7Ozs7O2tDQUFFO0FBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtBTFQsIENPTlRST0wsIE1BQ19NRVRBLCBNRVRBLCBTSElGVH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcbmltcG9ydCB7SW5qZWN0LCBJbmplY3RhYmxlLCBJbmplY3Rpb25Ub2tlbiwgT25EZXN0cm95LCBPcHRpb25hbCwgTmdab25lfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7bm9ybWFsaXplUGFzc2l2ZUxpc3RlbmVyT3B0aW9ucywgUGxhdGZvcm0sIF9nZXRFdmVudFRhcmdldH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BsYXRmb3JtJztcbmltcG9ydCB7RE9DVU1FTlR9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0JlaGF2aW9yU3ViamVjdCwgT2JzZXJ2YWJsZX0gZnJvbSAncnhqcyc7XG5pbXBvcnQge2Rpc3RpbmN0VW50aWxDaGFuZ2VkLCBza2lwfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge1xuICBpc0Zha2VNb3VzZWRvd25Gcm9tU2NyZWVuUmVhZGVyLFxuICBpc0Zha2VUb3VjaHN0YXJ0RnJvbVNjcmVlblJlYWRlcixcbn0gZnJvbSAnLi4vZmFrZS1ldmVudC1kZXRlY3Rpb24nO1xuXG4vKipcbiAqIFRoZSBpbnB1dCBtb2RhbGl0aWVzIGRldGVjdGVkIGJ5IHRoaXMgc2VydmljZS4gTnVsbCBpcyB1c2VkIGlmIHRoZSBpbnB1dCBtb2RhbGl0eSBpcyB1bmtub3duLlxuICovXG5leHBvcnQgdHlwZSBJbnB1dE1vZGFsaXR5ID0gJ2tleWJvYXJkJyB8ICdtb3VzZScgfCAndG91Y2gnIHwgbnVsbDtcblxuLyoqIE9wdGlvbnMgdG8gY29uZmlndXJlIHRoZSBiZWhhdmlvciBvZiB0aGUgSW5wdXRNb2RhbGl0eURldGVjdG9yLiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbnB1dE1vZGFsaXR5RGV0ZWN0b3JPcHRpb25zIHtcbiAgLyoqIEtleXMgdG8gaWdub3JlIHdoZW4gZGV0ZWN0aW5nIGtleWJvYXJkIGlucHV0IG1vZGFsaXR5LiAqL1xuICBpZ25vcmVLZXlzPzogbnVtYmVyW107XG59XG5cbi8qKlxuICogSW5qZWN0YWJsZSBvcHRpb25zIGZvciB0aGUgSW5wdXRNb2RhbGl0eURldGVjdG9yLiBUaGVzZSBhcmUgc2hhbGxvd2x5IG1lcmdlZCB3aXRoIHRoZSBkZWZhdWx0XG4gKiBvcHRpb25zLlxuICovXG5leHBvcnQgY29uc3QgSU5QVVRfTU9EQUxJVFlfREVURUNUT1JfT1BUSU9OUyA9XG4gIG5ldyBJbmplY3Rpb25Ub2tlbjxJbnB1dE1vZGFsaXR5RGV0ZWN0b3JPcHRpb25zPignY2RrLWlucHV0LW1vZGFsaXR5LWRldGVjdG9yLW9wdGlvbnMnKTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBJbnB1dE1vZGFsaXR5RGV0ZWN0b3IuXG4gKlxuICogTW9kaWZpZXIga2V5cyBhcmUgaWdub3JlZCBieSBkZWZhdWx0IChpLmUuIHdoZW4gcHJlc3NlZCB3b24ndCBjYXVzZSB0aGUgc2VydmljZSB0byBkZXRlY3RcbiAqIGtleWJvYXJkIGlucHV0IG1vZGFsaXR5KSBmb3IgdHdvIHJlYXNvbnM6XG4gKlxuICogMS4gTW9kaWZpZXIga2V5cyBhcmUgY29tbW9ubHkgdXNlZCB3aXRoIG1vdXNlIHRvIHBlcmZvcm0gYWN0aW9ucyBzdWNoIGFzICdyaWdodCBjbGljaycgb3IgJ29wZW5cbiAqICAgIGluIG5ldyB0YWInLCBhbmQgYXJlIHRodXMgbGVzcyByZXByZXNlbnRhdGl2ZSBvZiBhY3R1YWwga2V5Ym9hcmQgaW50ZXJhY3Rpb24uXG4gKiAyLiBWb2ljZU92ZXIgdHJpZ2dlcnMgc29tZSBrZXlib2FyZCBldmVudHMgd2hlbiBsaW5lYXJseSBuYXZpZ2F0aW5nIHdpdGggQ29udHJvbCArIE9wdGlvbiAoYnV0XG4gKiAgICBjb25mdXNpbmdseSBub3Qgd2l0aCBDYXBzIExvY2spLiBUaHVzLCB0byBoYXZlIHBhcml0eSB3aXRoIG90aGVyIHNjcmVlbiByZWFkZXJzLCB3ZSBpZ25vcmVcbiAqICAgIHRoZXNlIGtleXMgc28gYXMgdG8gbm90IHVwZGF0ZSB0aGUgaW5wdXQgbW9kYWxpdHkuXG4gKlxuICogTm90ZSB0aGF0IHdlIGRvIG5vdCBieSBkZWZhdWx0IGlnbm9yZSB0aGUgcmlnaHQgTWV0YSBrZXkgb24gU2FmYXJpIGJlY2F1c2UgaXQgaGFzIHRoZSBzYW1lIGtleVxuICogY29kZSBhcyB0aGUgQ29udGV4dE1lbnUga2V5IG9uIG90aGVyIGJyb3dzZXJzLiBXaGVuIHdlIHN3aXRjaCB0byB1c2luZyBldmVudC5rZXksIHdlIGNhblxuICogZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGUgdHdvLlxuICovXG5leHBvcnQgY29uc3QgSU5QVVRfTU9EQUxJVFlfREVURUNUT1JfREVGQVVMVF9PUFRJT05TOiBJbnB1dE1vZGFsaXR5RGV0ZWN0b3JPcHRpb25zID0ge1xuICBpZ25vcmVLZXlzOiBbQUxULCBDT05UUk9MLCBNQUNfTUVUQSwgTUVUQSwgU0hJRlRdLFxufTtcblxuLyoqXG4gKiBUaGUgYW1vdW50IG9mIHRpbWUgbmVlZGVkIHRvIHBhc3MgYWZ0ZXIgYSB0b3VjaHN0YXJ0IGV2ZW50IGluIG9yZGVyIGZvciBhIHN1YnNlcXVlbnQgbW91c2Vkb3duXG4gKiBldmVudCB0byBiZSBhdHRyaWJ1dGVkIGFzIG1vdXNlIGFuZCBub3QgdG91Y2guXG4gKlxuICogVGhpcyBpcyB0aGUgdmFsdWUgdXNlZCBieSBBbmd1bGFySlMgTWF0ZXJpYWwuIFRocm91Z2ggdHJpYWwgYW5kIGVycm9yIChvbiBpUGhvbmUgNlMpIHRoZXkgZm91bmRcbiAqIHRoYXQgYSB2YWx1ZSBvZiBhcm91bmQgNjUwbXMgc2VlbXMgYXBwcm9wcmlhdGUuXG4gKi9cbmV4cG9ydCBjb25zdCBUT1VDSF9CVUZGRVJfTVMgPSA2NTA7XG5cbi8qKlxuICogRXZlbnQgbGlzdGVuZXIgb3B0aW9ucyB0aGF0IGVuYWJsZSBjYXB0dXJpbmcgYW5kIGFsc28gbWFyayB0aGUgbGlzdGVuZXIgYXMgcGFzc2l2ZSBpZiB0aGUgYnJvd3NlclxuICogc3VwcG9ydHMgaXQuXG4gKi9cbmNvbnN0IG1vZGFsaXR5RXZlbnRMaXN0ZW5lck9wdGlvbnMgPSBub3JtYWxpemVQYXNzaXZlTGlzdGVuZXJPcHRpb25zKHtcbiAgcGFzc2l2ZTogdHJ1ZSxcbiAgY2FwdHVyZTogdHJ1ZSxcbn0pO1xuXG4vKipcbiAqIFNlcnZpY2UgdGhhdCBkZXRlY3RzIHRoZSB1c2VyJ3MgaW5wdXQgbW9kYWxpdHkuXG4gKlxuICogVGhpcyBzZXJ2aWNlIGRvZXMgbm90IHVwZGF0ZSB0aGUgaW5wdXQgbW9kYWxpdHkgd2hlbiBhIHVzZXIgbmF2aWdhdGVzIHdpdGggYSBzY3JlZW4gcmVhZGVyXG4gKiAoZS5nLiBsaW5lYXIgbmF2aWdhdGlvbiB3aXRoIFZvaWNlT3Zlciwgb2JqZWN0IG5hdmlnYXRpb24gLyBicm93c2UgbW9kZSB3aXRoIE5WREEsIHZpcnR1YWwgUENcbiAqIGN1cnNvciBtb2RlIHdpdGggSkFXUykuIFRoaXMgaXMgaW4gcGFydCBkdWUgdG8gdGVjaG5pY2FsIGxpbWl0YXRpb25zIChpLmUuIGtleWJvYXJkIGV2ZW50cyBkbyBub3RcbiAqIGZpcmUgYXMgZXhwZWN0ZWQgaW4gdGhlc2UgbW9kZXMpIGJ1dCBpcyBhbHNvIGFyZ3VhYmx5IHRoZSBjb3JyZWN0IGJlaGF2aW9yLiBOYXZpZ2F0aW5nIHdpdGggYVxuICogc2NyZWVuIHJlYWRlciBpcyBha2luIHRvIHZpc3VhbGx5IHNjYW5uaW5nIGEgcGFnZSwgYW5kIHNob3VsZCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMgYWN0dWFsIHVzZXJcbiAqIGlucHV0IGludGVyYWN0aW9uLlxuICpcbiAqIFdoZW4gYSB1c2VyIGlzIG5vdCBuYXZpZ2F0aW5nIGJ1dCAqaW50ZXJhY3RpbmcqIHdpdGggYSBzY3JlZW4gcmVhZGVyLCB0aGlzIHNlcnZpY2UgYXR0ZW1wdHMgdG9cbiAqIHVwZGF0ZSB0aGUgaW5wdXQgbW9kYWxpdHkgdG8ga2V5Ym9hcmQsIGJ1dCBpbiBnZW5lcmFsIHRoaXMgc2VydmljZSdzIGJlaGF2aW9yIGlzIGxhcmdlbHlcbiAqIHVuZGVmaW5lZC5cbiAqL1xuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBJbnB1dE1vZGFsaXR5RGV0ZWN0b3IgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICAvKiogRW1pdHMgd2hlbmV2ZXIgYW4gaW5wdXQgbW9kYWxpdHkgaXMgZGV0ZWN0ZWQuICovXG4gIHJlYWRvbmx5IG1vZGFsaXR5RGV0ZWN0ZWQ6IE9ic2VydmFibGU8SW5wdXRNb2RhbGl0eT47XG5cbiAgLyoqIEVtaXRzIHdoZW4gdGhlIGlucHV0IG1vZGFsaXR5IGNoYW5nZXMuICovXG4gIHJlYWRvbmx5IG1vZGFsaXR5Q2hhbmdlZDogT2JzZXJ2YWJsZTxJbnB1dE1vZGFsaXR5PjtcblxuICAvKiogVGhlIG1vc3QgcmVjZW50bHkgZGV0ZWN0ZWQgaW5wdXQgbW9kYWxpdHkuICovXG4gIGdldCBtb3N0UmVjZW50TW9kYWxpdHkoKTogSW5wdXRNb2RhbGl0eSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGFsaXR5LnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtb3N0IHJlY2VudGx5IGRldGVjdGVkIGlucHV0IG1vZGFsaXR5IGV2ZW50IHRhcmdldC4gSXMgbnVsbCBpZiBubyBpbnB1dCBtb2RhbGl0eSBoYXMgYmVlblxuICAgKiBkZXRlY3RlZCBvciBpZiB0aGUgYXNzb2NpYXRlZCBldmVudCB0YXJnZXQgaXMgbnVsbCBmb3Igc29tZSB1bmtub3duIHJlYXNvbi5cbiAgICovXG4gIF9tb3N0UmVjZW50VGFyZ2V0OiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsO1xuXG4gIC8qKiBUaGUgdW5kZXJseWluZyBCZWhhdmlvclN1YmplY3QgdGhhdCBlbWl0cyB3aGVuZXZlciBhbiBpbnB1dCBtb2RhbGl0eSBpcyBkZXRlY3RlZC4gKi9cbiAgcHJpdmF0ZSByZWFkb25seSBfbW9kYWxpdHkgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PElucHV0TW9kYWxpdHk+KG51bGwpO1xuXG4gIC8qKiBPcHRpb25zIGZvciB0aGlzIElucHV0TW9kYWxpdHlEZXRlY3Rvci4gKi9cbiAgcHJpdmF0ZSByZWFkb25seSBfb3B0aW9uczogSW5wdXRNb2RhbGl0eURldGVjdG9yT3B0aW9ucztcblxuICAvKipcbiAgICogVGhlIHRpbWVzdGFtcCBvZiB0aGUgbGFzdCB0b3VjaCBpbnB1dCBtb2RhbGl0eS4gVXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciBtb3VzZWRvd24gZXZlbnRzXG4gICAqIHNob3VsZCBiZSBhdHRyaWJ1dGVkIHRvIG1vdXNlIG9yIHRvdWNoLlxuICAgKi9cbiAgcHJpdmF0ZSBfbGFzdFRvdWNoTXMgPSAwO1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGtleWRvd24gZXZlbnRzLiBNdXN0IGJlIGFuIGFycm93IGZ1bmN0aW9uIGluIG9yZGVyIHRvIHByZXNlcnZlIHRoZSBjb250ZXh0IHdoZW4gaXQgZ2V0c1xuICAgKiBib3VuZC5cbiAgICovXG4gIHByaXZhdGUgX29uS2V5ZG93biA9IChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgIC8vIElmIHRoaXMgaXMgb25lIG9mIHRoZSBrZXlzIHdlIHNob3VsZCBpZ25vcmUsIHRoZW4gaWdub3JlIGl0IGFuZCBkb24ndCB1cGRhdGUgdGhlIGlucHV0XG4gICAgLy8gbW9kYWxpdHkgdG8ga2V5Ym9hcmQuXG4gICAgaWYgKHRoaXMuX29wdGlvbnM/Lmlnbm9yZUtleXM/LnNvbWUoa2V5Q29kZSA9PiBrZXlDb2RlID09PSBldmVudC5rZXlDb2RlKSkgeyByZXR1cm47IH1cblxuICAgIHRoaXMuX21vZGFsaXR5Lm5leHQoJ2tleWJvYXJkJyk7XG4gICAgdGhpcy5fbW9zdFJlY2VudFRhcmdldCA9IF9nZXRFdmVudFRhcmdldChldmVudCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBtb3VzZWRvd24gZXZlbnRzLiBNdXN0IGJlIGFuIGFycm93IGZ1bmN0aW9uIGluIG9yZGVyIHRvIHByZXNlcnZlIHRoZSBjb250ZXh0IHdoZW4gaXRcbiAgICogZ2V0cyBib3VuZC5cbiAgICovXG4gIHByaXZhdGUgX29uTW91c2Vkb3duID0gKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgLy8gVG91Y2hlcyB0cmlnZ2VyIGJvdGggdG91Y2ggYW5kIG1vdXNlIGV2ZW50cywgc28gd2UgbmVlZCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIG1vdXNlIGV2ZW50c1xuICAgIC8vIHRoYXQgd2VyZSB0cmlnZ2VyZWQgdmlhIG1vdXNlIHZzIHRvdWNoLiBUbyBkbyBzbywgY2hlY2sgaWYgdGhlIG1vdXNlIGV2ZW50IG9jY3VycyBjbG9zZWx5XG4gICAgLy8gYWZ0ZXIgdGhlIHByZXZpb3VzIHRvdWNoIGV2ZW50LlxuICAgIGlmIChEYXRlLm5vdygpIC0gdGhpcy5fbGFzdFRvdWNoTXMgPCBUT1VDSF9CVUZGRVJfTVMpIHsgcmV0dXJuOyB9XG5cbiAgICAvLyBGYWtlIG1vdXNlZG93biBldmVudHMgYXJlIGZpcmVkIGJ5IHNvbWUgc2NyZWVuIHJlYWRlcnMgd2hlbiBjb250cm9scyBhcmUgYWN0aXZhdGVkIGJ5IHRoZVxuICAgIC8vIHNjcmVlbiByZWFkZXIuIEF0dHJpYnV0ZSB0aGVtIHRvIGtleWJvYXJkIGlucHV0IG1vZGFsaXR5LlxuICAgIHRoaXMuX21vZGFsaXR5Lm5leHQoaXNGYWtlTW91c2Vkb3duRnJvbVNjcmVlblJlYWRlcihldmVudCkgPyAna2V5Ym9hcmQnIDogJ21vdXNlJyk7XG4gICAgdGhpcy5fbW9zdFJlY2VudFRhcmdldCA9IF9nZXRFdmVudFRhcmdldChldmVudCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0b3VjaHN0YXJ0IGV2ZW50cy4gTXVzdCBiZSBhbiBhcnJvdyBmdW5jdGlvbiBpbiBvcmRlciB0byBwcmVzZXJ2ZSB0aGUgY29udGV4dCB3aGVuIGl0XG4gICAqIGdldHMgYm91bmQuXG4gICAqL1xuICBwcml2YXRlIF9vblRvdWNoc3RhcnQgPSAoZXZlbnQ6IFRvdWNoRXZlbnQpID0+IHtcbiAgICAvLyBTYW1lIHNjZW5hcmlvIGFzIG1lbnRpb25lZCBpbiBfb25Nb3VzZWRvd24sIGJ1dCBvbiB0b3VjaCBzY3JlZW4gZGV2aWNlcywgZmFrZSB0b3VjaHN0YXJ0XG4gICAgLy8gZXZlbnRzIGFyZSBmaXJlZC4gQWdhaW4sIGF0dHJpYnV0ZSB0byBrZXlib2FyZCBpbnB1dCBtb2RhbGl0eS5cbiAgICBpZiAoaXNGYWtlVG91Y2hzdGFydEZyb21TY3JlZW5SZWFkZXIoZXZlbnQpKSB7XG4gICAgICB0aGlzLl9tb2RhbGl0eS5uZXh0KCdrZXlib2FyZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFN0b3JlIHRoZSB0aW1lc3RhbXAgb2YgdGhpcyB0b3VjaCBldmVudCwgYXMgaXQncyB1c2VkIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gbW91c2UgZXZlbnRzXG4gICAgLy8gdHJpZ2dlcmVkIHZpYSBtb3VzZSB2cyB0b3VjaC5cbiAgICB0aGlzLl9sYXN0VG91Y2hNcyA9IERhdGUubm93KCk7XG5cbiAgICB0aGlzLl9tb2RhbGl0eS5uZXh0KCd0b3VjaCcpO1xuICAgIHRoaXMuX21vc3RSZWNlbnRUYXJnZXQgPSBfZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBwcml2YXRlIHJlYWRvbmx5IF9wbGF0Zm9ybTogUGxhdGZvcm0sXG4gICAgICBuZ1pvbmU6IE5nWm9uZSxcbiAgICAgIEBJbmplY3QoRE9DVU1FTlQpIGRvY3VtZW50OiBEb2N1bWVudCxcbiAgICAgIEBPcHRpb25hbCgpIEBJbmplY3QoSU5QVVRfTU9EQUxJVFlfREVURUNUT1JfT1BUSU9OUylcbiAgICAgIG9wdGlvbnM/OiBJbnB1dE1vZGFsaXR5RGV0ZWN0b3JPcHRpb25zLFxuICApIHtcbiAgICB0aGlzLl9vcHRpb25zID0ge1xuICAgICAgLi4uSU5QVVRfTU9EQUxJVFlfREVURUNUT1JfREVGQVVMVF9PUFRJT05TLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuXG4gICAgLy8gU2tpcCB0aGUgZmlyc3QgZW1pc3Npb24gYXMgaXQncyBudWxsLlxuICAgIHRoaXMubW9kYWxpdHlEZXRlY3RlZCA9IHRoaXMuX21vZGFsaXR5LnBpcGUoc2tpcCgxKSk7XG4gICAgdGhpcy5tb2RhbGl0eUNoYW5nZWQgPSB0aGlzLm1vZGFsaXR5RGV0ZWN0ZWQucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcblxuICAgIC8vIElmIHdlJ3JlIG5vdCBpbiBhIGJyb3dzZXIsIHRoaXMgc2VydmljZSBzaG91bGQgZG8gbm90aGluZywgYXMgdGhlcmUncyBubyByZWxldmFudCBpbnB1dFxuICAgIC8vIG1vZGFsaXR5IHRvIGRldGVjdC5cbiAgICBpZiAoIV9wbGF0Zm9ybS5pc0Jyb3dzZXIpIHsgcmV0dXJuOyB9XG5cbiAgICAvLyBBZGQgdGhlIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIGRldGVjdCB0aGUgdXNlcidzIGlucHV0IG1vZGFsaXR5LlxuICAgIG5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25LZXlkb3duLCBtb2RhbGl0eUV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2Vkb3duLCBtb2RhbGl0eUV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoc3RhcnQsIG1vZGFsaXR5RXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgaWYgKCF0aGlzLl9wbGF0Zm9ybS5pc0Jyb3dzZXIpIHsgcmV0dXJuOyB9XG5cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25LZXlkb3duLCBtb2RhbGl0eUV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlZG93biwgbW9kYWxpdHlFdmVudExpc3RlbmVyT3B0aW9ucyk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hzdGFydCwgbW9kYWxpdHlFdmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIH1cbn1cbiJdfQ==